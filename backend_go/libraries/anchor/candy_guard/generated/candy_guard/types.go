// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package candy_guard

import (
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
)

type AddressGate struct {
	Address ag_solanago.PublicKey
}

func (obj AddressGate) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Address` param:
	err = encoder.Encode(obj.Address)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddressGate) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Address`:
	err = decoder.Decode(&obj.Address)
	if err != nil {
		return err
	}
	return nil
}

type Allocation struct {
	Id    uint8
	Limit uint32
}

func (obj Allocation) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Id` param:
	err = encoder.Encode(obj.Id)
	if err != nil {
		return err
	}
	// Serialize `Limit` param:
	err = encoder.Encode(obj.Limit)
	if err != nil {
		return err
	}
	return nil
}

func (obj *Allocation) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	// Deserialize `Limit`:
	err = decoder.Decode(&obj.Limit)
	if err != nil {
		return err
	}
	return nil
}

type AllocationTracker struct {
	Count uint32
}

func (obj AllocationTracker) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Count` param:
	err = encoder.Encode(obj.Count)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AllocationTracker) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Count`:
	err = decoder.Decode(&obj.Count)
	if err != nil {
		return err
	}
	return nil
}

type AllowList struct {
	MerkleRoot [32]uint8
}

func (obj AllowList) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `MerkleRoot` param:
	err = encoder.Encode(obj.MerkleRoot)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AllowList) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `MerkleRoot`:
	err = decoder.Decode(&obj.MerkleRoot)
	if err != nil {
		return err
	}
	return nil
}

type AllowListProof struct {
	Timestamp int64
}

func (obj AllowListProof) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Timestamp` param:
	err = encoder.Encode(obj.Timestamp)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AllowListProof) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Timestamp`:
	err = decoder.Decode(&obj.Timestamp)
	if err != nil {
		return err
	}
	return nil
}

type BotTax struct {
	Lamports        uint64
	LastInstruction bool
}

func (obj BotTax) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Lamports` param:
	err = encoder.Encode(obj.Lamports)
	if err != nil {
		return err
	}
	// Serialize `LastInstruction` param:
	err = encoder.Encode(obj.LastInstruction)
	if err != nil {
		return err
	}
	return nil
}

func (obj *BotTax) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Lamports`:
	err = decoder.Decode(&obj.Lamports)
	if err != nil {
		return err
	}
	// Deserialize `LastInstruction`:
	err = decoder.Decode(&obj.LastInstruction)
	if err != nil {
		return err
	}
	return nil
}

type EndDate struct {
	Date int64
}

func (obj EndDate) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Date` param:
	err = encoder.Encode(obj.Date)
	if err != nil {
		return err
	}
	return nil
}

func (obj *EndDate) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Date`:
	err = decoder.Decode(&obj.Date)
	if err != nil {
		return err
	}
	return nil
}

type FreezeSolPayment struct {
	Lamports    uint64
	Destination ag_solanago.PublicKey
}

func (obj FreezeSolPayment) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Lamports` param:
	err = encoder.Encode(obj.Lamports)
	if err != nil {
		return err
	}
	// Serialize `Destination` param:
	err = encoder.Encode(obj.Destination)
	if err != nil {
		return err
	}
	return nil
}

func (obj *FreezeSolPayment) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Lamports`:
	err = decoder.Decode(&obj.Lamports)
	if err != nil {
		return err
	}
	// Deserialize `Destination`:
	err = decoder.Decode(&obj.Destination)
	if err != nil {
		return err
	}
	return nil
}

type FreezeTokenPayment struct {
	Amount         uint64
	Mint           ag_solanago.PublicKey
	DestinationAta ag_solanago.PublicKey
}

func (obj FreezeTokenPayment) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Amount` param:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return err
	}
	// Serialize `Mint` param:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return err
	}
	// Serialize `DestinationAta` param:
	err = encoder.Encode(obj.DestinationAta)
	if err != nil {
		return err
	}
	return nil
}

func (obj *FreezeTokenPayment) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	// Deserialize `DestinationAta`:
	err = decoder.Decode(&obj.DestinationAta)
	if err != nil {
		return err
	}
	return nil
}

type Gatekeeper struct {
	GatekeeperNetwork ag_solanago.PublicKey
	ExpireOnUse       bool
}

func (obj Gatekeeper) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `GatekeeperNetwork` param:
	err = encoder.Encode(obj.GatekeeperNetwork)
	if err != nil {
		return err
	}
	// Serialize `ExpireOnUse` param:
	err = encoder.Encode(obj.ExpireOnUse)
	if err != nil {
		return err
	}
	return nil
}

func (obj *Gatekeeper) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `GatekeeperNetwork`:
	err = decoder.Decode(&obj.GatekeeperNetwork)
	if err != nil {
		return err
	}
	// Deserialize `ExpireOnUse`:
	err = decoder.Decode(&obj.ExpireOnUse)
	if err != nil {
		return err
	}
	return nil
}

type MintLimit struct {
	Id    uint8
	Limit uint16
}

func (obj MintLimit) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Id` param:
	err = encoder.Encode(obj.Id)
	if err != nil {
		return err
	}
	// Serialize `Limit` param:
	err = encoder.Encode(obj.Limit)
	if err != nil {
		return err
	}
	return nil
}

func (obj *MintLimit) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	// Deserialize `Limit`:
	err = decoder.Decode(&obj.Limit)
	if err != nil {
		return err
	}
	return nil
}

type MintCounter struct {
	Count uint16
}

func (obj MintCounter) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Count` param:
	err = encoder.Encode(obj.Count)
	if err != nil {
		return err
	}
	return nil
}

func (obj *MintCounter) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Count`:
	err = decoder.Decode(&obj.Count)
	if err != nil {
		return err
	}
	return nil
}

type NftBurn struct {
	RequiredCollection ag_solanago.PublicKey
}

func (obj NftBurn) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `RequiredCollection` param:
	err = encoder.Encode(obj.RequiredCollection)
	if err != nil {
		return err
	}
	return nil
}

func (obj *NftBurn) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `RequiredCollection`:
	err = decoder.Decode(&obj.RequiredCollection)
	if err != nil {
		return err
	}
	return nil
}

type NftGate struct {
	RequiredCollection ag_solanago.PublicKey
}

func (obj NftGate) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `RequiredCollection` param:
	err = encoder.Encode(obj.RequiredCollection)
	if err != nil {
		return err
	}
	return nil
}

func (obj *NftGate) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `RequiredCollection`:
	err = decoder.Decode(&obj.RequiredCollection)
	if err != nil {
		return err
	}
	return nil
}

type NftMintLimit struct {
	Id                 uint8
	Limit              uint16
	RequiredCollection ag_solanago.PublicKey
}

func (obj NftMintLimit) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Id` param:
	err = encoder.Encode(obj.Id)
	if err != nil {
		return err
	}
	// Serialize `Limit` param:
	err = encoder.Encode(obj.Limit)
	if err != nil {
		return err
	}
	// Serialize `RequiredCollection` param:
	err = encoder.Encode(obj.RequiredCollection)
	if err != nil {
		return err
	}
	return nil
}

func (obj *NftMintLimit) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	// Deserialize `Limit`:
	err = decoder.Decode(&obj.Limit)
	if err != nil {
		return err
	}
	// Deserialize `RequiredCollection`:
	err = decoder.Decode(&obj.RequiredCollection)
	if err != nil {
		return err
	}
	return nil
}

type NftMintCounter struct {
	Count uint16
}

func (obj NftMintCounter) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Count` param:
	err = encoder.Encode(obj.Count)
	if err != nil {
		return err
	}
	return nil
}

func (obj *NftMintCounter) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Count`:
	err = decoder.Decode(&obj.Count)
	if err != nil {
		return err
	}
	return nil
}

type NftPayment struct {
	RequiredCollection ag_solanago.PublicKey
	Destination        ag_solanago.PublicKey
}

func (obj NftPayment) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `RequiredCollection` param:
	err = encoder.Encode(obj.RequiredCollection)
	if err != nil {
		return err
	}
	// Serialize `Destination` param:
	err = encoder.Encode(obj.Destination)
	if err != nil {
		return err
	}
	return nil
}

func (obj *NftPayment) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `RequiredCollection`:
	err = decoder.Decode(&obj.RequiredCollection)
	if err != nil {
		return err
	}
	// Deserialize `Destination`:
	err = decoder.Decode(&obj.Destination)
	if err != nil {
		return err
	}
	return nil
}

type ProgramGate struct {
	Additional []ag_solanago.PublicKey
}

func (obj ProgramGate) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Additional` param:
	err = encoder.Encode(obj.Additional)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ProgramGate) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Additional`:
	err = decoder.Decode(&obj.Additional)
	if err != nil {
		return err
	}
	return nil
}

type RedeemedAmount struct {
	Maximum uint64
}

func (obj RedeemedAmount) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Maximum` param:
	err = encoder.Encode(obj.Maximum)
	if err != nil {
		return err
	}
	return nil
}

func (obj *RedeemedAmount) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Maximum`:
	err = decoder.Decode(&obj.Maximum)
	if err != nil {
		return err
	}
	return nil
}

type SolFixedFee struct {
	Lamports    uint64
	Destination ag_solanago.PublicKey
}

func (obj SolFixedFee) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Lamports` param:
	err = encoder.Encode(obj.Lamports)
	if err != nil {
		return err
	}
	// Serialize `Destination` param:
	err = encoder.Encode(obj.Destination)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SolFixedFee) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Lamports`:
	err = decoder.Decode(&obj.Lamports)
	if err != nil {
		return err
	}
	// Deserialize `Destination`:
	err = decoder.Decode(&obj.Destination)
	if err != nil {
		return err
	}
	return nil
}

type SolPayment struct {
	Lamports    uint64
	Destination ag_solanago.PublicKey
}

func (obj SolPayment) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Lamports` param:
	err = encoder.Encode(obj.Lamports)
	if err != nil {
		return err
	}
	// Serialize `Destination` param:
	err = encoder.Encode(obj.Destination)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SolPayment) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Lamports`:
	err = decoder.Decode(&obj.Lamports)
	if err != nil {
		return err
	}
	// Deserialize `Destination`:
	err = decoder.Decode(&obj.Destination)
	if err != nil {
		return err
	}
	return nil
}

type StartDate struct {
	Date int64
}

func (obj StartDate) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Date` param:
	err = encoder.Encode(obj.Date)
	if err != nil {
		return err
	}
	return nil
}

func (obj *StartDate) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Date`:
	err = decoder.Decode(&obj.Date)
	if err != nil {
		return err
	}
	return nil
}

type ThirdPartySigner struct {
	SignerKey ag_solanago.PublicKey
}

func (obj ThirdPartySigner) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `SignerKey` param:
	err = encoder.Encode(obj.SignerKey)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ThirdPartySigner) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `SignerKey`:
	err = decoder.Decode(&obj.SignerKey)
	if err != nil {
		return err
	}
	return nil
}

type Token2022Payment struct {
	Amount         uint64
	Mint           ag_solanago.PublicKey
	DestinationAta ag_solanago.PublicKey
}

func (obj Token2022Payment) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Amount` param:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return err
	}
	// Serialize `Mint` param:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return err
	}
	// Serialize `DestinationAta` param:
	err = encoder.Encode(obj.DestinationAta)
	if err != nil {
		return err
	}
	return nil
}

func (obj *Token2022Payment) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	// Deserialize `DestinationAta`:
	err = decoder.Decode(&obj.DestinationAta)
	if err != nil {
		return err
	}
	return nil
}

type TokenBurn struct {
	Amount uint64
	Mint   ag_solanago.PublicKey
}

func (obj TokenBurn) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Amount` param:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return err
	}
	// Serialize `Mint` param:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TokenBurn) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	return nil
}

type TokenGate struct {
	Amount uint64
	Mint   ag_solanago.PublicKey
}

func (obj TokenGate) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Amount` param:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return err
	}
	// Serialize `Mint` param:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TokenGate) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	return nil
}

type TokenPayment struct {
	Amount         uint64
	Mint           ag_solanago.PublicKey
	DestinationAta ag_solanago.PublicKey
}

func (obj TokenPayment) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Amount` param:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return err
	}
	// Serialize `Mint` param:
	err = encoder.Encode(obj.Mint)
	if err != nil {
		return err
	}
	// Serialize `DestinationAta` param:
	err = encoder.Encode(obj.DestinationAta)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TokenPayment) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	// Deserialize `DestinationAta`:
	err = decoder.Decode(&obj.DestinationAta)
	if err != nil {
		return err
	}
	return nil
}

type RouteArgs struct {
	Guard GuardType
	Data  []byte
}

func (obj RouteArgs) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Guard` param:
	err = encoder.Encode(obj.Guard)
	if err != nil {
		return err
	}
	// Serialize `Data` param:
	err = encoder.Encode(obj.Data)
	if err != nil {
		return err
	}
	return nil
}

func (obj *RouteArgs) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Guard`:
	err = decoder.Decode(&obj.Guard)
	if err != nil {
		return err
	}
	// Deserialize `Data`:
	err = decoder.Decode(&obj.Data)
	if err != nil {
		return err
	}
	return nil
}

type CandyGuardData struct {
	Default GuardSet
	Groups  *[]Group `bin:"optional"`
}

func (obj CandyGuardData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Default` param:
	err = encoder.Encode(obj.Default)
	if err != nil {
		return err
	}
	// Serialize `Groups` param (optional):
	{
		if obj.Groups == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.Groups)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *CandyGuardData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Default`:
	err = decoder.Decode(&obj.Default)
	if err != nil {
		return err
	}
	// Deserialize `Groups` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.Groups)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type Group struct {
	Label  string
	Guards GuardSet
}

func (obj Group) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Label` param:
	err = encoder.Encode(obj.Label)
	if err != nil {
		return err
	}
	// Serialize `Guards` param:
	err = encoder.Encode(obj.Guards)
	if err != nil {
		return err
	}
	return nil
}

func (obj *Group) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Label`:
	err = decoder.Decode(&obj.Label)
	if err != nil {
		return err
	}
	// Deserialize `Guards`:
	err = decoder.Decode(&obj.Guards)
	if err != nil {
		return err
	}
	return nil
}

type GuardSet struct {
	BotTax             *BotTax             `bin:"optional"`
	SolPayment         *SolPayment         `bin:"optional"`
	TokenPayment       *TokenPayment       `bin:"optional"`
	StartDate          *StartDate          `bin:"optional"`
	ThirdPartySigner   *ThirdPartySigner   `bin:"optional"`
	TokenGate          *TokenGate          `bin:"optional"`
	Gatekeeper         *Gatekeeper         `bin:"optional"`
	EndDate            *EndDate            `bin:"optional"`
	AllowList          *AllowList          `bin:"optional"`
	MintLimit          *MintLimit          `bin:"optional"`
	NftPayment         *NftPayment         `bin:"optional"`
	RedeemedAmount     *RedeemedAmount     `bin:"optional"`
	AddressGate        *AddressGate        `bin:"optional"`
	NftGate            *NftGate            `bin:"optional"`
	NftBurn            *NftBurn            `bin:"optional"`
	TokenBurn          *TokenBurn          `bin:"optional"`
	FreezeSolPayment   *FreezeSolPayment   `bin:"optional"`
	FreezeTokenPayment *FreezeTokenPayment `bin:"optional"`
	ProgramGate        *ProgramGate        `bin:"optional"`
	Allocation         *Allocation         `bin:"optional"`
	NftMintLimit       *NftMintLimit       `bin:"optional"`
	SolFixedFee        *SolFixedFee        `bin:"optional"`
	Token2022Payment   *Token2022Payment   `bin:"optional"`
}

func (obj GuardSet) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `BotTax` param (optional):
	{
		if obj.BotTax == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.BotTax)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `SolPayment` param (optional):
	{
		if obj.SolPayment == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.SolPayment)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `TokenPayment` param (optional):
	{
		if obj.TokenPayment == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.TokenPayment)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `StartDate` param (optional):
	{
		if obj.StartDate == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.StartDate)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `ThirdPartySigner` param (optional):
	{
		if obj.ThirdPartySigner == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.ThirdPartySigner)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `TokenGate` param (optional):
	{
		if obj.TokenGate == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.TokenGate)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `Gatekeeper` param (optional):
	{
		if obj.Gatekeeper == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.Gatekeeper)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `EndDate` param (optional):
	{
		if obj.EndDate == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.EndDate)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `AllowList` param (optional):
	{
		if obj.AllowList == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.AllowList)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `MintLimit` param (optional):
	{
		if obj.MintLimit == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.MintLimit)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `NftPayment` param (optional):
	{
		if obj.NftPayment == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.NftPayment)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `RedeemedAmount` param (optional):
	{
		if obj.RedeemedAmount == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.RedeemedAmount)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `AddressGate` param (optional):
	{
		if obj.AddressGate == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.AddressGate)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `NftGate` param (optional):
	{
		if obj.NftGate == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.NftGate)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `NftBurn` param (optional):
	{
		if obj.NftBurn == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.NftBurn)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `TokenBurn` param (optional):
	{
		if obj.TokenBurn == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.TokenBurn)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `FreezeSolPayment` param (optional):
	{
		if obj.FreezeSolPayment == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.FreezeSolPayment)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `FreezeTokenPayment` param (optional):
	{
		if obj.FreezeTokenPayment == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.FreezeTokenPayment)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `ProgramGate` param (optional):
	{
		if obj.ProgramGate == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.ProgramGate)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `Allocation` param (optional):
	{
		if obj.Allocation == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.Allocation)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `NftMintLimit` param (optional):
	{
		if obj.NftMintLimit == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.NftMintLimit)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `SolFixedFee` param (optional):
	{
		if obj.SolFixedFee == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.SolFixedFee)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `Token2022Payment` param (optional):
	{
		if obj.Token2022Payment == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.Token2022Payment)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (obj *GuardSet) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `BotTax` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.BotTax)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `SolPayment` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.SolPayment)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `TokenPayment` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.TokenPayment)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `StartDate` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.StartDate)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `ThirdPartySigner` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.ThirdPartySigner)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `TokenGate` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.TokenGate)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `Gatekeeper` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.Gatekeeper)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `EndDate` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.EndDate)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `AllowList` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.AllowList)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `MintLimit` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.MintLimit)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `NftPayment` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.NftPayment)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `RedeemedAmount` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.RedeemedAmount)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `AddressGate` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.AddressGate)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `NftGate` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.NftGate)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `NftBurn` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.NftBurn)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `TokenBurn` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.TokenBurn)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `FreezeSolPayment` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.FreezeSolPayment)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `FreezeTokenPayment` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.FreezeTokenPayment)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `ProgramGate` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.ProgramGate)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `Allocation` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.Allocation)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `NftMintLimit` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.NftMintLimit)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `SolFixedFee` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.SolFixedFee)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `Token2022Payment` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.Token2022Payment)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

type FreezeInstruction ag_binary.BorshEnum

const (
	FreezeInstructionInitialize FreezeInstruction = iota
	FreezeInstructionThaw
	FreezeInstructionUnlockFunds
	FreezeInstructionAdminUnlockFunds
)

func (value FreezeInstruction) String() string {
	switch value {
	case FreezeInstructionInitialize:
		return "Initialize"
	case FreezeInstructionThaw:
		return "Thaw"
	case FreezeInstructionUnlockFunds:
		return "UnlockFunds"
	case FreezeInstructionAdminUnlockFunds:
		return "AdminUnlockFunds"
	default:
		return ""
	}
}

type GuardType ag_binary.BorshEnum

const (
	GuardTypeBotTax GuardType = iota
	GuardTypeSolPayment
	GuardTypeTokenPayment
	GuardTypeStartDate
	GuardTypeThirdPartySigner
	GuardTypeTokenGate
	GuardTypeGatekeeper
	GuardTypeEndDate
	GuardTypeAllowList
	GuardTypeMintLimit
	GuardTypeNftPayment
	GuardTypeRedeemedAmount
	GuardTypeAddressGate
	GuardTypeNftGate
	GuardTypeNftBurn
	GuardTypeTokenBurn
	GuardTypeFreezeSolPayment
	GuardTypeFreezeTokenPayment
	GuardTypeProgramGate
	GuardTypeAllocation
	GuardTypeNftMintLimit
	GuardTypeSolFixedFee
	GuardTypeToken2022Payment
)

func (value GuardType) String() string {
	switch value {
	case GuardTypeBotTax:
		return "BotTax"
	case GuardTypeSolPayment:
		return "SolPayment"
	case GuardTypeTokenPayment:
		return "TokenPayment"
	case GuardTypeStartDate:
		return "StartDate"
	case GuardTypeThirdPartySigner:
		return "ThirdPartySigner"
	case GuardTypeTokenGate:
		return "TokenGate"
	case GuardTypeGatekeeper:
		return "Gatekeeper"
	case GuardTypeEndDate:
		return "EndDate"
	case GuardTypeAllowList:
		return "AllowList"
	case GuardTypeMintLimit:
		return "MintLimit"
	case GuardTypeNftPayment:
		return "NftPayment"
	case GuardTypeRedeemedAmount:
		return "RedeemedAmount"
	case GuardTypeAddressGate:
		return "AddressGate"
	case GuardTypeNftGate:
		return "NftGate"
	case GuardTypeNftBurn:
		return "NftBurn"
	case GuardTypeTokenBurn:
		return "TokenBurn"
	case GuardTypeFreezeSolPayment:
		return "FreezeSolPayment"
	case GuardTypeFreezeTokenPayment:
		return "FreezeTokenPayment"
	case GuardTypeProgramGate:
		return "ProgramGate"
	case GuardTypeAllocation:
		return "Allocation"
	case GuardTypeNftMintLimit:
		return "NftMintLimit"
	case GuardTypeSolFixedFee:
		return "SolFixedFee"
	case GuardTypeToken2022Payment:
		return "Token2022Payment"
	default:
		return ""
	}
}
